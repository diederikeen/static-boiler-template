/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/assets/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/dload-lazyload/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/dload-lazyload/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dLoad = __webpack_require__(/*! ./partials/d-load */ \"./node_modules/dload-lazyload/lib/partials/d-load.js\");\n\nvar _dLoad2 = _interopRequireDefault(_dLoad);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _dLoad2.default;\n\n//# sourceURL=webpack:///./node_modules/dload-lazyload/lib/index.js?");

/***/ }),

/***/ "./node_modules/dload-lazyload/lib/partials/createImageObject.js":
/*!***********************************************************************!*\
  !*** ./node_modules/dload-lazyload/lib/partials/createImageObject.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar createImageObject = function () {\n\n  /**\n   * \n   * @param {Element to be animated} el \n   * @param {ClassName to be added once loaded} className \n   */\n\n  function createImageObject(el, className, singleSource) {\n    var _this = this;\n\n    _classCallCheck(this, createImageObject);\n\n    this.className = className;\n    this.item = el;\n    this.isSingleSource = singleSource;\n    this.mobile = this.isMobile();\n    this.tablet = this.isTablet();\n    this.retina = this.isRetina();\n    this.delay = this.setDelay();\n    this.type = el.tagName;\n\n    /**\n     * If type not equals an image tag or figure tag, we just add the class \n     * to trigger the animation / load. \n     */\n\n    if (this.type !== 'IMG' && this.type !== 'FIGURE') {\n      setTimeout(function () {\n        _this.item.classList.add(_this.className);\n      }, this.delay);\n\n      return false;\n    }\n\n    /**\n     * If everthing passed, create new image Instance;\n     */\n    this.source = this.setSource();\n\n    /**\n     * Throw error if image cannot be loaded due a undefined image url;\n     */\n    if (this.type === 'IMG' && this.source === undefined || this.type === 'FIGURE' && this.source === undefined) {\n      throw Error(\"Couldn't load image source. Please check source\");\n    }\n\n    this.createImage();\n  }\n\n  _createClass(createImageObject, [{\n    key: 'setDelay',\n    value: function setDelay() {\n      if (!this.item.classList.contains('reveal--random')) return 0;\n\n      var rand = Math.floor(Math.random() * 700) + 100;\n      return rand;\n    }\n  }, {\n    key: 'createImage',\n    value: function createImage() {\n      var _this2 = this;\n\n      this.image = new Image();\n      this.image.src = this.source;\n      this.image.onload = function () {\n\n        if (_this2.type === 'IMG') {\n          _this2.item.src = _this2.source;\n        } else {\n          _this2.item.style.backgroundImage = 'url(' + _this2.source + ')';\n        }\n\n        setTimeout(function () {\n          _this2.item.classList.add(_this2.className);\n        }, _this2.delay);\n      };\n\n      this.image.onerror = function (error) {\n        _this2.item.classList.add(_this2.className);\n        // console.error(error);\n      };\n    }\n  }, {\n    key: 'setSource',\n    value: function setSource() {\n      var srcset = this.item.dataset.srcset;\n\n      if (this.isSingleSource) return this.setSingleSource(srcset);else return this.setMultipleSources(srcset);\n    }\n  }, {\n    key: 'setSingleSource',\n    value: function setSingleSource(src) {\n      return src;\n    }\n  }, {\n    key: 'setMultipleSources',\n    value: function setMultipleSources(src) {\n      var _this3 = this;\n\n      var object = JSON.parse(src);\n      var sources = ['default', 'tablet', 'mobile'];\n      var srcString = void 0;\n\n      sources.map(function (source) {\n\n        if (_this3.retina) {\n          if (_this3[source]) {\n            srcString = object[source + 'Retina'] || object[source];\n            if (!srcString) srcString = object['defaultRetina'] || object['default'];\n            return srcString;\n          } else if (!srcString) {\n            srcString = object['defaultRetina'] || object['default'];\n            return srcString;\n          }\n        } else {\n          if (_this3[source]) {\n            srcString = object[source] || object['default'];\n          } else {\n            srcString = object['default'];\n          }\n        }\n      });\n\n      return srcString;\n    }\n  }, {\n    key: 'isMobile',\n    value: function isMobile() {\n      if (window.innerWidth < 768) {\n        return true;\n      };\n      return false;\n    }\n  }, {\n    key: 'isTablet',\n    value: function isTablet() {\n      if (window.innerWidth >= 768 && window.innerWidth < 970) {\n        return true;\n      };\n\n      return false;\n    }\n  }, {\n    key: 'isRetina',\n    value: function isRetina() {\n      var mediaQuery = \"(-webkit-min-device-pixel-ratio: 1.5),\\\n            (min--moz-device-pixel-ratio: 1.5),\\\n            (-o-min-device-pixel-ratio: 3/2),\\\n            (min-resolution: 1.5dppx)\";\n\n      if (window.devicePixelRatio > 1) {\n        return true;\n      };\n\n      if (window.matchMedia && window.matchMedia(mediaQuery).matches) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return createImageObject;\n}();\n\nexports.default = createImageObject;\n\n//# sourceURL=webpack:///./node_modules/dload-lazyload/lib/partials/createImageObject.js?");

/***/ }),

/***/ "./node_modules/dload-lazyload/lib/partials/d-load.js":
/*!************************************************************!*\
  !*** ./node_modules/dload-lazyload/lib/partials/d-load.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createImageObject = __webpack_require__(/*! ./createImageObject */ \"./node_modules/dload-lazyload/lib/partials/createImageObject.js\");\n\nvar _createImageObject2 = _interopRequireDefault(_createImageObject);\n\nvar _throttleDebounce = __webpack_require__(/*! throttle-debounce */ \"./node_modules/throttle-debounce/dist/index.esm.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar dload = function dload(parameters) {\n  /**\n   * Set default classes if none is given in the parameters;\n  */\n\n  var options = setDefaultOptions(parameters);\n  var lazyElements = Array.prototype.slice.call(document.getElementsByClassName(options.className));\n\n  /**\n   * Throw error if there no elements, but classname exits;\n   */\n  if (!lazyElements.length) {\n    return;\n  };\n  setImageSources(lazyElements, options.loadedClass, options.singleSource);\n\n  /**\n   * Check if there still images after init\n   * if so, add eventlistener;\n   */\n  if (!lazyElements.length) {\n    return false;\n  };\n\n  window.addEventListener('scroll', (0, _throttleDebounce.throttle)(50, function () {\n    setImageSources(lazyElements, options.loadedClass, options.singleSource);\n  }));\n\n  window.addEventListener('touchmove', (0, _throttleDebounce.throttle)(50, function () {\n    setImageSources(lazyElements, options.loadedClass, options.singleSource);\n  }));\n};\n\n/**\n * Set Default options\n */\nvar setDefaultOptions = function setDefaultOptions(parameters) {\n  var options = {};\n\n  if (!parameters) {\n    return {\n      className: \"lazy-load\",\n      loadedClass: \"lazy-loaded\",\n      singleSource: false\n    };\n  };\n\n  if (!parameters['className']) {\n    options.className = \"lazy-load\";\n  } else {\n    options.className = parameters.className;\n  }\n\n  if (!parameters['loadedClass']) {\n    options.loadedClass = \"lazy-loaded\";\n  } else {\n    options.loadedClass = parameters.loadedClass;\n  }\n\n  if (!parameters['singleSource']) {\n    options.singleSource = false;\n  } else {\n    options.singleSource = parameters.singleSource;\n  }\n\n  if (!options.loadedClass || !options.className) {\n    throw Error('Either the default class name or loaded class name failed to set.');\n  }\n\n  return options;\n};\n\n/**\n * Check if element is in view\n */\nvar isElementInView = function isElementInView(el) {\n  var rect = el.getBoundingClientRect();\n  return rect.top >= 0 && rect.bottom <= (window.innerHeight + el.clientHeight || document.documentElement.clientHeight + el.clientHeight);\n};\n\n/**\n * Create image instance\n */\nvar setImageSources = function setImageSources(elements, className, singleSource) {\n  for (var i = elements.length - 1; i >= 0; i--) {\n    var el = elements[i];\n    if (isElementInView(el)) {\n      new _createImageObject2.default(el, className, singleSource);\n      removeItemFromArray(el, elements);\n    }\n  }\n};\n\nvar removeItemFromArray = function removeItemFromArray(el, elements) {\n  var i = elements.indexOf(el);\n  if (i > -1) {\n    elements.splice(i, 1);\n  };\n\n  return elements;\n};\n\nexports.default = dload;\n\n//# sourceURL=webpack:///./node_modules/dload-lazyload/lib/partials/d-load.js?");

/***/ }),

/***/ "./node_modules/smoothscroll-polyfill/dist/smoothscroll.js":
/*!*****************************************************************!*\
  !*** ./node_modules/smoothscroll-polyfill/dist/smoothscroll.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      while (el !== d.body && isScrollable(el) === false) {\n        el = el.parentNode || el.host;\n      }\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (true) {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {}\n\n}());\n\n\n//# sourceURL=webpack:///./node_modules/smoothscroll-polyfill/dist/smoothscroll.js?");

/***/ }),

/***/ "./node_modules/throttle-debounce/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/throttle-debounce/dist/index.esm.js ***!
  \**********************************************************/
/*! exports provided: throttle, debounce */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throttle\", function() { return throttle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debounce\", function() { return debounce; });\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset)\n * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @return {Function}  A new, throttled, function.\n */\nfunction throttle (delay, noTrailing, callback, debounceMode) {\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel() {\n    clearExistingTimeout();\n    cancelled = true;\n  } // `noTrailing` defaults to falsy.\n\n\n  if (typeof noTrailing !== 'boolean') {\n    debounceMode = callback;\n    callback = noTrailing;\n    noTrailing = undefined;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n    var args = arguments;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, args);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */\n      exec();\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}  [atBegin]     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @return {Function} A new, debounced function.\n */\n\nfunction debounce (delay, atBegin, callback) {\n  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/throttle-debounce/dist/index.esm.js?");

/***/ }),

/***/ "./src/assets/js/index.js":
/*!********************************!*\
  !*** ./src/assets/js/index.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var dload_lazyload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dload-lazyload */ \"./node_modules/dload-lazyload/lib/index.js\");\n/* harmony import */ var dload_lazyload__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dload_lazyload__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var smoothscroll_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! smoothscroll-polyfill */ \"./node_modules/smoothscroll-polyfill/dist/smoothscroll.js\");\n/* harmony import */ var smoothscroll_polyfill__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(smoothscroll_polyfill__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _partials_navigationActions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./partials/navigationActions */ \"./src/assets/js/partials/navigationActions.js\");\n/* harmony import */ var _partials_navigationActions__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_partials_navigationActions__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  smoothscroll_polyfill__WEBPACK_IMPORTED_MODULE_1___default.a.polyfill();\n\n  dload_lazyload__WEBPACK_IMPORTED_MODULE_0___default()({\n    className: 'reveal',\n    singleSource: true,\n  });\n});\n\n\n//# sourceURL=webpack:///./src/assets/js/index.js?");

/***/ }),

/***/ "./src/assets/js/partials/navigationActions.js":
/*!*****************************************************!*\
  !*** ./src/assets/js/partials/navigationActions.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const navs = document.getElementsByClassName('m-nav');\n\nfunction initNavActions() {\n  const bodyTag = document.body;\n  let currentScrollPosition = window.scrollY;\n  let ticking = false;\n  let isScrolling = null;\n\n  function scrollToTarget(id) {\n    const target = document.getElementById(id);\n    target.scrollIntoView({ behavior: 'smooth' });\n  }\n\n  function setClasses() {\n    clearInterval(isScrolling);\n    bodyTag.classList.add('no-overflow');\n  }\n\n  function doSomething() {\n    const bool = window.scrollY === currentScrollPosition;\n    if (bool) setClasses(doSomething);\n  }\n\n  function handleClick(event) {\n    const { currentTarget } = event;\n    const id = currentTarget.getAttribute('href').replace('#', '');\n\n    setTimeout(() => {\n      scrollToTarget(id);\n      isScrolling = setInterval(doSomething, 300);\n    }, 250);\n\n    if (bodyTag.classList.contains('no-overflow')) bodyTag.classList.remove('no-overflow');\n    event.preventDefault();\n  }\n\n  [].map.call(navs, (nav) => {\n    const anchors = nav.getElementsByTagName('a');\n\n    [].map.call(anchors, (anchor) => {\n      anchor.addEventListener('click', handleClick);\n    });\n  });\n\n  window.addEventListener('scroll', () => {\n    currentScrollPosition = window.scrollY;\n\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        ticking = false;\n      });\n      ticking = true;\n    }\n  });\n}\n\ninitNavActions();\n\n\n//# sourceURL=webpack:///./src/assets/js/partials/navigationActions.js?");

/***/ })

/******/ });